# 构建一个CRUD API

本次构建一个影片管理的API，信息暂时都在内存中存储，涉及的内容如下：

| ROUTES    | FUNCTIONS   |  ENDPOINT  | METHOD |
|-----------|-------------|:----------:|:------:|
| GET ALL   | getMovies   | /movies    |   GET  |
| GET BY ID | getMovie    | /movie/id  |   GET  |
| CREATE    | createMovie | /movies    |  POST  |
| UPDATE    | updateMovie | /movies/id |   PUT  |
| DELETE    | deleteMovie | /movies/id | DELETE |

最后成品可以用postman这种测试工具来验证API的功能。

## 安装依赖
项目中涉及很多的url，这通过gorilla/mux组件来实现。开始前需要先安装这个依赖：
```shell
go get "github.com/gorilla/mux"
```
如果不在GOPATH/src下创建项目文件夹，需要先执行如下命令：
```shell
go mod init <project_name>
```

## 开始编写
```golang
package main

import (
    "fmt"
    "log"
    "strconv"
    "encoding/json"
    "math/rand"
    "net/http"
    "github.com/gorilla/mux"
)
```

### 定义一些结构
每个影片有片名，演员，导演，发行时间，上映时间等内容，导演也有姓名等信息。我们将这些信息组合在一起，方便将来引用和存储。

```golang
type Movie struct {
    ID string  `json: "id"`
    Isbn string `json: "isbn"`
    Title string `json: "title"`
    Director *Director `json: "director"`
}

type Director struct {
    Firstname string `json: "firstname"`
    Lastname string `json: "lastname"`
}
```
### 定义影片信息
同样，为了保存影片内容，我们定义一个数组：
```golang
var movies []Movie
```

### 创建一些影片信息

### 主函数
创建五个路由。
```golang

func main(){
    director1 := Director{Firstname: "John", Lastname: "Doe"}
    director2 := Director{Firstname: "Steven", Lastname: "Smith"}
    
    movies = append(movies, Movie{ID: "1", Isbn: "12345", Title: "To the Moon", Director: &director1})
    movies = append(movies, Movie{ID: "2", Isbn: "22345", Title: "To the Moon, Again", Director: &director1})
    
    movies = append(movies, Movie{
    ID: "3", Isbn: "32345", Title: "Under the sea", Director: &director2
    })
    
    r := mux.NewRouter()
    
    r.handleFunc("/movies", getMovies).Methods("GET")
    r.handleFunc("/movies/{id}", getMovie).Methods("GET")
    r.handleFunc("/movies", createMovie).Methods("POST")
    r.handleFunc("/movies/{id}", updateMovie).Methods("PUT")
    r.handleFunc("/movies/{id}", deleteMovie).Methods("DELETE")
    
    fmt.Printf("Starting server at port 8080\n")
    log.Fatal(http.ListenAndServe(":8080", r))
}
```

### 实现具体路由
对于代码中用不到的变量，需要用_接收，否则go编译器会报错。
*本想编写一个函数写入返回的值，但是不知道怎么写即可是列表又可以是单个元素的函数。*
<!-- 知道怎么写了，用|来连接两种或者多种类型，这是python的语法，不对
```go
func write(w http.ResponseWriter, d Movie | []Movie){
    json.NewEncoder(w).Encode(d)
}
``` -->

```golang
func setHeader(w http.ResponseWriter){
    w.Header().Set("Content-Type", "application/json")
}

func getMovies(w http.ResponseWriter, r *http.Request){
    setHeader(w)
    json.NewEncoder(w).Encode(movies)
}

func deleteMovie(w http.ResponseWriter, r *http.Request){
    setHeader(w)
    params := mux.Vars(r)
    for index, item := range(movies) {
        if item.ID == params["id"] {
            movies = append(movies[:index], movies[index+1:]...)
            break
        }
    }
    json.NewEncoder(w).Encode(movies)
}

func getMovie(w http.ResponseWriter, r *http.Request){
    setHeader(w)
    params := mux.Vars(r)
    for _, item := range(movies) {
        if item.ID == params["id"] {
            json.NewEncoder(w).Encode(item)
            return
        }
    }
}

func createMovie(w http.ResponseWriter, r *http.Request){
    setHeader(w)
    var movie Movie
    json.NewDecoder(r.Body).Decode(&movie)
    movie.ID = strconv.Itoa(rand.Intn(10000000))
    movies = append(movies, movie)
    json.NewEncoder(w).Encode(movies)
}

func updateMovie(w http.ResponseWriter, r *http.Request){
    setHeader(w)
    params := mux.Vars(r)
    var movie Movie
    movie.ID = params["id"]  // 小心这里的ID可能被前端传来的值修改，保险起见可以放在下一句之后
    json.NewDecoder(r.Body).Decode(&movie) // 这里只会解析前端传来的值并覆盖更新对应的字段
    for index, item := range(movies) {
        if item.ID == params["id"] {
            movies = append(movies[:index], movies[index+1:]...)  // 这里只能用...，参数不能多
            movies = append(movies, movie)
            json.NewEncoder(w).Encode(movies)
            break
        }
    }
}
```

### 编译程序

```shell
go build
```
目录下会出现执行`go mod init <project_name>`时制定的project_name相同的编译好的文件。可以直接运行它，也可以用`go run main.go`来执行。

### 运行程序
此时运行如下命令（可能会报错）：
```shell
go run main.go
```
之后用postman访问8080端口下相应的url，测试效果。

### 排错
> main.go:9:5: no required module provides package github.com/gorilla/mux: go.mod file not found in current directory or any parent directory; see 'go help modules'

原因是新版本的golang为了方便模块管理，做了调整，需要做相应设置:
> go version go1.16.13 linux/amd64

查看env设置，发现GO111MODULE=""，将其设置成auto
```shell
go env  # 查看环境变量
GO111MODULE=""  # 相应的输出

go env -w GO111MODULE=auto  # 设置环境变量
```

如果程序目录在GOPATH/src之外，还会报错。此时可以在项目目录下执行以下命令可解决：
```shell
go mod init <project_name>  # 会创建一个go.mod文件，包含项目信息，这里project_name可以包含目录，如import package定义类似，最终也只会用最后一部分作为build出来的文件的名称。

go get github.com/gorilla/mux  # 会将这个依赖添加到go.mod文件中，并生成一个go.sum文件，其中包含依赖的md5值
```
