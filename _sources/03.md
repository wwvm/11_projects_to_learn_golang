# 图书管理系统API

构建一个图书管理系统API，后端采用MySQL数据库存储数据，通过Gorilla Mux进行路由管理，用GORM进行模型映射。通过JSON进行前后端数据交互。系统划分为配置，控制器，模型，路由以及工具模块。

## 项目设置
1. 如果打算在GOPATH/src目录之外创建项目，需要初始化模块。`go mod init bookstore`
2. 安装依赖项目
在项目内的任意目录均可以执行。

```shell 
go get github.com/jinzhu/gorm
go get github.com/jinzhu/gorm/dialects/mysql # 这会下载mysql驱动，跟执行go mod download github.com/go-sql-driver/mysql效果一样
go get github.com/gorilla/mux
```
3. 创建目录结构
```shell 
mkdir -p cmd/main pkg/{config,controllers,models,routes,utils}
touch cmd/main/main.go pkg/config/app.go pkg/controllers/book-controller.go pkg/models/book.go pkg/routes/bookstore-routes.go pkg/utils/utils.go
```

## 代码编制
### 路由routes
从最简单的路由设置开始。位于pkg/routes文件夹下，名称任意。

```go 
package routes

import (
    "github.com/gorilla/mux"
    "bookstore/pkg/controllers"

)

var RegisterRoutes = func(r *mux.Router){
    r.HandleFunc("/books", controllers.CreateBook).Methods("POST")
    r.HandleFunc("/books", controllers.GetAllBooks).Methods("GET")
    r.HandleFunc("/books/{id}", controllers.GetBookById).Methods("GET")
    r.HandleFunc("/books/{id}", controllers.UpdateBook).Methods("PUT")
    r.HandleFunc("/books/{id}", controllers.DeleteBook).Methods("DELETE")
}
```

### 数据库配置config
位于pkg/config目录下，名称随意。
```go 
package config

import (
    "github.com/jinzhu/gorm"
    _ "github.com/jinzhu/gorm/dialects/mysql"
)

var (
    db *gorm.DB
)

func Connect(){
    d, err := gorm.Open("mysql", "root:Ctbc123!@tcp(10.124.44.30:3306)/bookstore?charset=utf8&parseTime=True&loc=Local")
    if err != nil {
        panic(err)
    }
    db = d
}

func GetDB() *gorm.DB {
    return db
}
```

### utils
位于pkg/utils文件夹下，名称随意，甚至可以是全数字命名。

```go
package utils

import (
    "encoding/json"
    "io/ioutil"
    "net/http"
)

func ParseBody(r *http.Request, x interface{}){
    if body, err := ioutil.ReadAll(r.Body); err == nil {
        if err := json.Unmarshal([]byte(body), x); err != nil {
            return 
        }
    }
}
```

### 模型
```go
package models

import (
    "github.com/jinzhu/gorm"
    "bookstore/pkg/config"
)

var db *gorm.DB

type Book struct {
    gorm.Model   // 内置模型，包含created，updated，deleted时间以及id字段
    Name string `gorm: ""json:"name"`    // 不知道为啥这里还写一个gorm，但是现象是返回的数据中Name首字母大写，author等就是全小写。
    Author string `json:"author"`
    Publication string `json:"publication"`
}

func init(){
    config.Connect()
    db = config.GetDB()
    db.AutoMigrate(&Book{})
}

func (b *Book) CreateBook() *Book {  // why here define as a method?
    db.NewRecord(b)  // how this work? 传进来的b已经初始化了，
    db.Create(&b) // 会把ID赋值，这里其实就已经修改了传入的参数了，没必要再return了
    return b
}

func GetAllBooks() []Book{
    var books []Book
    db.Find(&books)
    return books
}

func GetBookById(id int64) (*Book, *gorm.DB){ // why here also return db? A. for update
    var book Book
    db := db.Where("ID=?", id).Find(&book)
    return &book, db
}

func DeleteBook(id int64) Book{
    var book Book
    db.Where("ID=?", id).Delete(book)  // why here not use reference? Both reference or not are ok!!
    return book
}
```
### 主函数
位于cmd/main文件夹下，

```go
package main

import (
    "log"
    "net/http"
    "github.com/gorilla/mux"
    _ "github.com/jinzhu/gorm/dialects/mysql"
    "bookstore/pkg/routes"
)

func main(){
    r := mux.NewRouter()
    routes.RegisterRoutes(r)
    http.Handle("/", r)
    log.Fatal(http.ListenAndServe(":8080", r))
}
```

### 控制器
位于pkg/controllers文件夹下，文件名称任意。
```go
package controllers

import (
    "encoding/json"
    "fmt"
    "github.com/gorilla/mux"
    "net/http"
    "strconv"
    "bookstore/pkg/utils"
    "bookstore/pkg/models"
)


func write(w http.ResponseWriter, s int, d []byte){
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(s)
    w.Write(d)
}

func GetAllBooks(w http.ResponseWriter, r *http.Request){
    newBooks := models.GetAllBooks()
    res, _ := json.Marshal(newBooks)
    write(w, http.StatusOK, res)
}

func GetBookById(w http.ResponseWriter, r *http.Request){
    params := mux.Vars(r)
    id := params["id"]
    ID, err := strconv.ParseInt(id, 0, 0)
    if err != nil {
        fmt.Println("Error while parsing id.")
    }
    book, _ := models.GetBookById(ID)
    res, _ := json.Marshal(book)
    write(w, http.StatusOK, res)
}

func CreateBook(w http.ResponseWriter, r *http.Request){
    book := &models.Book{}
    utils.ParseBody(r, book)
    b := book.CreateBook() // 方法CreateBook会修改book本身，因此没必要接收返回参数，下一行可以直接用book进行Marshal
    res, _ := json.Marshal(b)
    write(w, http.StatusOK, res)
}

func DeleteBook(w http.ResponseWriter, r *http.Request){
    // 取得id
    params := mux.Vars(r)
    id := params["id"]
    id_int, err := strconv.ParseInt(id, 0, 0)
    if err != nil {
        fmt.Println("Error while parsing id.")
    }
    book := models.DeleteBook(id_int) // 为啥返回个空的呢？
    res, _ := json.Marshal(book)
    write(w, http.StatusOK, res)
}

func UpdateBook(w http.ResponseWriter, r *http.Request){
    params := mux.Vars(r)
    id := params["id"]
    id_int, err := strconv.ParseInt(id, 0, 0)
    if err != nil {
        fmt.Println("Error while parsing id.")
    }
    book := &models.Book{}
    utils.ParseBody(r, book)
    
    stored, db := models.GetBookById(id_int)
    
    if book.Name != "" {
        stored.Name = book.Name
    }
    if book.Author != "" {
        stored.Author = book.Author
    }
    if book.Publication != "" {
        stored.Publication = book.Publication
    }
    db.Save(&stored)  // 为啥是&？实验证明用和不用没啥区别，都能执行。只是用&的时候数据库里updated_at字段会更新，而不用的时候不更新
    
    res, _ := json.Marshal(stored)
    write(w, http.StatusOK, res)
}
```

## 测试运行
### 创建数据库
需要在mysql中先创建一个数据库，设定好访问方式。程序运行之后会自动创建表。

### 运行
可以在任意目录运行，只要文件目录正确即可。
```shell
go run cmd/main/app.go
```
